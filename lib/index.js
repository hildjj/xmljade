// Generated by CoffeeScript 1.10.0
(function() {
  var DEFAULT_CONFIG, dentToString, error, fix, fs, jade, path, pkg, req, temp, transform, xml;

  try {
    require('source-map-support').install();
  } catch (error) {

  }

  fs = require('fs');

  dentToString = require('dentin').dentToString;

  xml = require('libxmljs');

  jade = require('jade');

  pkg = require('../package');

  path = require('path');

  temp = require('temp').track();

  req = require;

  DEFAULT_CONFIG = "./.xmljade.json";

  fix = function(r) {
    var t;
    if (r == null) {
      return r;
    } else {
      t = typeof r;
      if (t === 'string' || t === 'number') {
        return r;
      } else {
        switch (r.type()) {
          case 'attribute':
            return r.value();
          case 'text':
            return r.text();
          default:
            return r;
        }
      }
    }
  };

  this.transform = transform = function(jadedata, xmldata, options, cb) {
    var cache, dopts, e, er, err, error1, error2, error3, fn, found, i, k, len1, out, pretty, ref, v, xmldoc, xopts;
    if (options == null) {
      options = {
        pretty: true
      };
    }
    if ((cb == null) || (typeof cb !== 'function')) {
      console.error('No callback');
      return;
    }
    pretty = options.pretty;
    options.pretty = false;
    xopts = {
      noent: true
    };
    if (typeof jadedata === 'funciton') {
      fn = jadedata;
    } else {
      try {
        if (options.xmljadeSource) {
          fn = jade.compileClient(jadedata, options);
        } else {
          fn = jade.compile(jadedata, options);
        }
      } catch (error1) {
        e = error1;
        return cb("Jade compile error: " + e.message);
      }
    }
    if (options.xmljadeSource) {
      try {
        fs.writeFileSync(options.xmljadeSource, fn.toString());
        if (xmldata == null) {
          return cb(null, null);
        }
      } catch (error2) {
        e = error2;
        return cb("Error writing xmljade source: " + e.message);
      }
    }
    if (xmldata instanceof xml.Document) {
      xmldoc = xmldata;
    } else {
      xmldoc = xml.parseXmlString(xmldata, xopts);
      if ((xmldoc != null ? xmldoc.errors.length : void 0) > 0) {
        er = "";
        ref = xmldoc.errors;
        for (i = 0, len1 = ref.length; i < len1; i++) {
          e = ref[i];
          e += "ERROR (input XML " + e.line + ":" + e.column + "): " + e.message + "\n";
        }
        return cb(e);
      }
    }
    cache = {};
    out = fn({
      defs: options.define,
      $: function(q, c, ns) {
        if (q == null) {
          q = '.';
        }
        if (c == null) {
          c = xmldoc;
        }
        if ((c != null) && (ns == null) && (!(c instanceof xml.Document)) && (!(c instanceof xml.Element))) {
          ns = c;
          c = xmldoc;
        }
        return fix(c.get(q, ns));
      },
      $$: function(q, c, ns) {
        var j, len2, r, ref1, results;
        if (q == null) {
          q = '.';
        }
        if (c == null) {
          c = xmldoc;
        }
        if ((c != null) && (ns == null) && (!(c instanceof xml.Document)) && (!(c instanceof xml.Element))) {
          ns = c;
          c = xmldoc;
        }
        ref1 = c.find(q, ns);
        results = [];
        for (j = 0, len2 = ref1.length; j < len2; j++) {
          r = ref1[j];
          results.push(fix(r));
        }
        return results;
      },
      $att: function(e, a) {
        var all, at, j, len2, n, ns, ref1, ref2, v;
        if (e == null) {
          return null;
        } else if ((a == null) || (typeof a === 'object')) {
          all = {};
          ref1 = e.attrs();
          for (j = 0, len2 = ref1.length; j < len2; j++) {
            at = ref1[j];
            v = at.value();
            if (v != null) {
              n = at.name();
              ns = at.namespace();
              if ((ns != null) && (ns.prefix() != null)) {
                n = ns.prefix() + ':' + n;
              }
              all[n] = v;
            }
          }
          if (a != null) {
            for (n in a) {
              v = a[n];
              if (v != null) {
                all[n] = v;
              }
            }
          }
          return all;
        } else {
          return (ref2 = e.attr(a)) != null ? ref2.value() : void 0;
        }
      },
      $element: function(name, content) {
        return new xml.Element(xmldoc, name, content);
      },
      $nsDecls: function(e, a) {
        var j, len2, n, ns, p, ref1, res, v;
        e = e || xmldoc.root();
        res = {};
        ref1 = e.namespaces(true);
        for (j = 0, len2 = ref1.length; j < len2; j++) {
          ns = ref1[j];
          n = 'xmlns';
          p = ns.prefix();
          if (p != null) {
            n += ':' + p;
          }
          res[n] = ns.href();
        }
        if (a != null) {
          for (n in a) {
            v = a[n];
            if (v != null) {
              res[n] = v;
            }
          }
        }
        return res;
      },
      $qname: function(e) {
        var ns;
        ns = e.namespace();
        if ((ns != null) && (ns.prefix() != null)) {
          return ns.prefix() + ":" + e.name();
        } else {
          return e.name();
        }
      },
      $root: function() {
        return xmldoc.root();
      },
      $source: xmldata,
      $sourceFile: options.xml,
      require: function(mod) {
        var dir, m, pth, tmp;
        m = cache[mod];
        if (m == null) {
          dir = null;
          if (options.filename != null) {
            dir = path.dirname(options.filename);
          }
          tmp = temp.openSync({
            dir: dir,
            suffix: ".js"
          });
          fs.writeSync(tmp.fd, "module.exports = require('" + mod + "');\n");
          fs.closeSync(tmp.fd);
          pth = path.resolve(process.cwd(), tmp.path);
          m = req(pth);
          cache[mod] = m;
          setImmediate(function() {
            return fs.unlinkSync(pth);
          });
        }
        return m;
      },
      version: pkg.name + " v" + pkg.version
    });
    if (pretty) {
      dopts = {};
      for (k in options) {
        v = options[k];
        found = false;
        k = k.replace(/^dentin-/, function() {
          found = true;
          return "";
        });
        if (found) {
          dopts[k] = v;
        }
      }
      if (dopts.html == null) {
        dopts.html = options.html;
      }
      try {
        out = dentToString(out, dopts);
      } catch (error3) {
        err = error3;
        return cb("Problem parsing output for pretty printing: " + err.message);
      }
    }
    cb(null, out);
    return out;
  };

  this.transformFile = function(jade, xml, options, cb) {
    var ref;
    if (options == null) {
      options = {
        pretty: true
      };
    }
    if (typeof options === 'function') {
      ref = [options, {}], cb = ref[0], options = ref[1];
    }
    if (cb == null) {
      cb = function() {};
    }
    return fs.readFile(jade, function(err, jadedata) {
      if (err != null) {
        return cb(err);
      }
      if (xml != null) {
        if (xml === '-') {
          xml = '/dev/stdin';
        }
        return fs.readFile(xml, function(err, xmldata) {
          if (err != null) {
            return cb(err);
          }
          options.filename = jade;
          options.xml = xml;
          return transform(jadedata, xmldata, options, cb);
        });
      } else {
        return transform(jadedata, null, options, cb);
      }
    });
  };

  this.read_config = function(opts, cb) {
    var cfg, ref;
    if (opts == null) {
      opts = {};
    }
    cfg = (ref = opts.config) != null ? ref : DEFAULT_CONFIG;
    if (cfg == null) {
      return cb(null, opts);
    }
    return fs.exists(cfg, function(exists) {
      if (!exists) {
        return cb(null, opts);
      }
      return fs.readFile(cfg, function(err, data) {
        var config, er, error1, k, v;
        if (err != null) {
          return cb(err);
        }
        try {
          config = JSON.parse(data);
          for (k in config) {
            v = config[k];
            if (opts[k] == null) {
              opts[k] = v;
            }
          }
          return cb(null, opts);
        } catch (error1) {
          er = error1;
          return cb(er);
        }
      });
    });
  };

  this.cmd = function(args, cb) {
    var commander, define, defs, len, opts, program;
    defs = {};
    define = function(v) {
      var m;
      m = v.match(/([^=]+)\s*=\s*(.*)/);
      if (!m) {
        return console.error("Invalid definition: '" + v + "'");
      } else {
        return defs[m[1]] = m[2];
      }
    };
    commander = require('commander');
    program = new commander.Command;
    program.version(pkg.version).usage('[options] <template> [input]').option('-c, --config <file>', "Config file to read [" + DEFAULT_CONFIG + "]", DEFAULT_CONFIG).option('-d, --debug', 'Add Jade debug information').option('-D, --define [name=string]', 'Define a global variable', define).option('--doublequote', 'Use doublequotes instead of single').option('-o, --output [file]', 'Output file').option('-p, --pretty', 'Pretty print').option('--html', 'HTML output; only useful for pretty printing').option('-s, --source [file]', 'Output source for client transformation').parse(args);
    len = program.args.len;
    if (((program.source != null) && (len < 1)) || (len < 2)) {
      program.help();
    }
    if (program.args.length < 1) {
      program.help();
    }
    opts = {
      pretty: program.pretty,
      compileDebug: program.debug,
      xmljadeSource: program.source,
      config: program.config,
      html: false,
      "dentin-doublequote": program.doublequote
    };
    if (program.html || ((program.output != null) && program.output.match(/\.html?$/))) {
      opts.html = true;
    }
    return this.read_config(opts, (function(_this) {
      return function(er, opts) {
        var k, v;
        if (er != null) {
          process.stderr.write(program.config + ": " + er.message + "\n");
          return cb(er);
        }
        if (opts.define != null) {
          for (k in defs) {
            v = defs[k];
            opts.define[k] = v;
          }
        } else {
          opts.define = defs;
        }
        return _this.transformFile(program.args[0], program.args[1], opts, function(er, output) {
          if (er != null) {
            return cb(er);
          }
          if (program.output != null) {
            return fs.writeFile(program.output, output, function(er) {
              if (er != null) {
                return cb(er);
              }
              return cb(null, output);
            });
          } else {
            if (output != null) {
              console.log(output);
            }
            return cb(null, output);
          }
        });
      };
    })(this));
  };

}).call(this);

//# sourceMappingURL=index.js.map
